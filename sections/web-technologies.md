# Web Technologies:

<details>
<summary>Что такое REST API?</summary>
<b>REST</b> (Representational State Transfer)  - это концепция (архитектура) для организации взаимодействия между независимыми объектами (приложениями) посредством протокола HTTP.
Включает в себя набор принципов (рекомендаций) взаимодействия клиент-серверных приложений. Обычно он представлен в формате JSON.

Основная идея REST API - разделение разных операций (чаще всего CRUD) при обращении к одному и тому же URL с помощью HTTP-методов.

Клиент посещает URL-адрес и отправляет серверу запрос, чтобы получить ответ.

![Test Image 4](https://github.com/danil2703/frontend-interview/blob/main/assets/web-technologies/1.png)
</details>

<details>
<summary>6 принципов архитектуры REST API</summary>

### 1. Клиент-серверная модель
Этот принцип требует отделять друг от друга два понятия: клиент и сервер.

Сервер — программа, в которой хранятся и обрабатываются ресурсы. Сервер может располагаться на одном или нескольких компьютерах; но даже в одном компьютере может быть несколько виртуальных серверов.

Клиент — программа, которая запрашивает у сервера доступ к ресурсам. Для этого она использует API.

### 2. Отсутствие состояния
Это значит, что на сервере не хранится никаких данных о прошлых взаимодействиях с клиентом — каждый запрос должен содержать всю информацию для его обработки.

Это снижает нагрузку на сервер, что особенно полезно, если к нему подключено одновременно много клиентов. Не нужно хранить дополнительную информацию о прошлых обращениях каждого из них. Достаточно обработать каждый запрос в отдельности.

### 3. Кэшируемость
Это ограничение требует, чтобы для данных в ответе на запрос явно было указано -- можно их кэшировать или нет. Если ответ поддерживает кэширование, то клиент имеет право повторно использовать данные в последующих эквивалентных запросов без обращения на сервер.

### 4. Единообразие интерфейса

Файлы обычно передаются клиенту не в том виде, в котором хранятся на сервере. В вебе их часто преобразуют в JSON или XML и только потом отправляют клиенту. Ответ на запросы к новому ресурсу должен приходить в том же формате, что и к старым, и сразу же содержать дополнительную информацию: что разрешается делать с ресурсом, можно ли его изменять и удалять на сервере и так далее.

REST накладывает на интерфейс четыре ограничения: 1) идентичность ресурсов; 2) манипуляция над ресурсами через представление; 3) исчерпывающие, понятные человеку сообщения; 4) гипермедиа (hypermedia) как движок для состояния приложения (HATEOAS).

### 5. Многоуровневая система

Многоуровневость достигается засчёт ограничения поведения компонентов таким образом, что компоненты "не видят" другие компоненты, кроме расположенных на ближайших уровнях, с которыми они взаимодействуют.

Между сервером и клиентом могут быть несколько промежуточных узлов, выполняющих вспомогательные функции, — прокси-серверы.

Они используются для кэширования, обеспечения безопасности, дополнительной обработки данных. Если основных серверов несколько, то дополнительные серверы-балансировщики могут распределять нагрузку между ними и решать, в какой из них направлять запрос:

Никто из участников цепочки не знает всего пути, который проходит запрос, — только своих «соседей» справа и слева.

![Test Image 4](https://github.com/danil2703/frontend-interview/blob/main/assets/web-technologies/2.png)

### 6. Код по требованию (необязательно)

Является необязательным принципом.

</details>

<details>
<summary>Разница между cookie, sessionStorage и localStorage?</summary>
<table>
    <thead>
        <tr>
            <th></th>
            <th><code>cookie</code></th>
            <th><code>localStorage</code></th>
            <th><code>sessionStorage</code></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Инициатор</td>
            <td>Клиент или сервер. Сервер может использовать заголовок <code>Set-Cookie</code></td>
            <td>Клиент</td>
            <td>Клиент</td>
        </tr>
        <tr>
            <td>Срок хранения</td>
            <td>Устанавливается вручную</td>
            <td>Всегда</td>
            <td>До закрытия вкладки</td>
        </tr>
        <tr>
            <td>Хранение между сессиями</td>
            <td>Зависит от установки срока хранения</td>
            <td>Да</td>
            <td>Нет</td>
        </tr>
        <tr>
            <td>Отправка на сервер с каждым HTTP-запросом</td>
            <td>автоматически, с помощью заголовка <code>Cookie</code></td>
            <td>Нет</td>
            <td>Нет</td>
        </tr>
        <tr>
            <td>Емкость (на один домен)</td>
            <td>4 КБ</td>
            <td>5 МБ</td>
            <td>5 МБ</td>
        </tr>
        <tr>
            <td>Доступность</td>
            <td>В любом окне</td>
            <td>В любом окне</td>
            <td>В той же вкладке</td>
        </tr>
    </tbody>
</table>
</details>

<details>
<summary>Что такое прогрессивный рендеринг?</summary>

Чтобы понять что такое progressive rendering, нужно понимать отличие client-side rendering от server-side rendering.

При client-side rendering (CSR) контент отрисовывается на стороне клиента (в браузере). Такой подход используется в React, когда браузеру отсылается практически пустой HTML-документ, а потом запускается скрипт, который генерирует HTML в указанном скрипту теге. Как правило это `<div id="root">`. Пользователь будет видеть пустую страницу, пока JS-файл полностью не загрузится.

При server-side rendering (SSR) HTML-разметка генерируется на сервере, отсылается браузеру и после этого отрисовывается на клиенте. Пользователь увидит контент сразу же, но не сможет взаимодействовать со страницей, пока не загрузится JS-файл.

При использовании прогрессивного рендеринга, кусочки HTML генерируется на сервере и отсылаются браузеру в порядке их приоритетности. То есть, элементы с самым высоким приоритетом (например `<header>`, фон, главная интерактивная часть страницы) генерируются на сервере, отсылаются браузеру и отрисовываются в первую очередь. Это позволяет пользователю увидеть самый важный контент как можно скорее, не дожидаясь полной загрузки всего контента. То есть, progressive rendering что-то среднее между client-side rendering и server-side rendering.

Техники реализации прогрессивного рендеринга:

Ленивая загрузка (Lazy Loading). Загрузка контента по мере необходимости. Например, если страница достаточно большая, не нужно загружать изображения вне вьюпорта. Загрузка изображения стартует за некоторое время до того как она появится во вьюпорте. Эту же технику можно использовать для загрузки контента изначально скрытых элементов. Например, можно загрузить контент закрытого меню когда пользователь наводит курсор на кнопку открытия.
Приоритизация контента. Например, не загружать изначально все CSS-стили. Добавлять в `<head>` загрузку только тех стилей, которые нужны для текущей видимой области HTML-документа. Остальные стили можно добавить в `<body>`.

</details>
